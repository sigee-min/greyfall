# Greyfall RTC Protocol

## Overview

The Greyfall realtime stack is built around two transports:

- **Signal transport** – a WebSocket bridge used only for WebRTC handshake exchange and ICE candidate relay.
- **Data transport** – a WebRTC data channel named `greyfall` that carries lobby and in-game control messages.

Both transports share a common envelope so that messages can be validated and versioned in a consistent way. The current protocol version is `1`.

## Envelope

All protocol messages share the following shape:

| Field    | Type      | Description                                    |
|----------|-----------|------------------------------------------------|
| `scope`  | string    | Logical subsystem (`"signal"`, `"lobby"`, ...)|
| `version`| number    | Schema version (`1` today).                     |
| `kind`   | string    | Message discriminator within the scope.        |
| `body`   | object    | Payload validated per `kind`.                  |

Messages that fail validation must be ignored and logged.

## Signal Transport

### Client → Server (`scope: "signal"`)

| Kind        | Body                                                                 |
|-------------|----------------------------------------------------------------------|
| `offer`     | `{ code: string }` – base64 encoded SDP generated by the host.        |
| `answer`    | `{ code: string }` – base64 encoded SDP generated by the guest.       |
| `candidate` | `{ candidate: string }` – ICE candidate relayed to the peer.          |
| `ping`      | `{}` – heartbeat from either peer.                                    |

### Server → Client (`scope: "signal"`)

| Kind               | Body                                                                     |
|--------------------|--------------------------------------------------------------------------|
| `ack`              | `{ role: "host" | "guest", sessionId: string }` – confirms registration.|
| `offer`            | `{ code: string }` – latest host offer (when a guest connects mid-stream).|
| `answer`           | `{ code: string }` – guest answer forwarded to the host.                 |
| `candidate`        | `{ candidate: string }` – ICE candidate relayed to the peer.             |
| `peer-connected`   | `{}` – remote peer joined.                                               |
| `peer-disconnected`| `{}` – remote peer left.                                                 |
| `pong`             | `{}` – heartbeat response.                                               |

### Session lifecycle

1. Host requests a session ID via `POST /sessions`.
2. Host opens a WebSocket at `/ws?session={ID}&role=host`.
3. Guest opens the WebSocket with `role=guest` after receiving a join code.
4. Both sides exchange `offer`/`answer` codes and optional ICE `candidate` records using the schema above.
5. Heartbeats (`ping`/`pong`) keep connections alive; no application state is transported via the signal channel.

## Data Transport (WebRTC Data Channel)

The only scope currently defined is `"lobby"`. Its message kinds and payloads are:

| Kind     | Body                                                                                          | Sent by |
|----------|-----------------------------------------------------------------------------------------------|---------|
| `hello`  | `{ participant: LobbyParticipant }`                                                           | guest   |
| `state`  | `{ participants: LobbyParticipant[] }`                                                        | host    |
| `ready`  | `{ participantId: string, ready: boolean }`                                                   | guest   |
| `leave`  | `{ participantId: string }`                                                                   | both    |
| `chat`   | `{ entry: LobbyChatMessage }`                                                                 | both    |

`LobbyParticipant` and `LobbyChatMessage` mirror the existing application store types (ID, display name, tag, role, timestamps, etc.).

Hosts always act as the source of truth for participant state. Guests announce themselves with `hello`, receive `state` snapshots, and emit `ready` and `chat` messages which are then rebroadcast by the host.

## Versioning

- The protocol version is attached to every message. When incrementing the version:
  - both signal and data channel handlers must reject mismatched versions;
  - backwards compatibility rules should be documented in this file.
- New scopes or kinds can be added without bumping the version as long as existing payloads remain backwards compatible.

## Validation Helpers

Shared Zod schemas and helpers live in `signal/src/protocol/schema.ts` and are re-exported to the client under `src/protocol`. All transport code should use those helpers instead of ad-hoc JSON parsing.

## Error Handling

- Invalid messages are ignored after logging a structured warning.
- Signal sessions are cleaned up when both peers disconnect or after a TTL (`30 minutes`).
- The data channel should fall back to host-only state if the channel closes unexpectedly; guests will exit the lobby.

## Future Work

- Add additional scopes (e.g. `"stage"`) for in-game state once the lobby protocol stabilises.
- Introduce protocol negotiation so older clients can downgrade gracefully instead of disconnecting.
